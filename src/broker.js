const {EventEmitter} = require('events');
const {AuthenticatedClient, WebsocketClient} = require('gdax');
const moment = require('moment');

const Order = require('./order');
const Engine = require('./engine');
const Process = require('./process');

/**
 * A class representing a broker.  Instance of this class are generated by the exchange
 */
class Broker extends EventEmitter {
  /**
   * A constructor used to create instances of the broker class
   * @param {Exchange} exchange - An instance of the Exchange class containing a websocket feed and an authenticated client for order execution (executor)
   */
  constructor(exchange={}) {
    super(exchange);
    this.exchange = exchange;
    this.enabled = false;
    this.queue = [];
    this.engine = new Engine(20);
    this.valid = this._testValid();
  }

  /**
   * Test validity of instances of broker class
   * @private
   * @return {boolean} Boolean representing the validity of instances of broker
   */
  _testValid() {
    return Boolean(
      this.exchange &&
      this.exchange.valid &&
      this.exchange.executor instanceof AuthenticatedClient &&
      this.exchange.feeds instanceof WebsocketClient &&
      this.engine instanceof Engine
    );
  }

  /**
   * A function to get the best limit price according to the current state of the
   * exchange orderbooks
   * @private
   * @param {Order} order - The order about which a current limit price will be determined
   * @return {number} The price of the best limit order
   */
  _getLimitPrice(order) {
    const currentOrderbook = this.exchange.orderbooks[order.product].book;
    const priceVector = currentOrderbook[order.side === 'buy' ? 'bids' : 'asks'];
    if (priceVector.length === 0) { return 0; }
    return order.side === 'buy' ? Number(priceVector[priceVector.length-1][0]) : Number(priceVector[0][0]);
  }

  /**
   * A function to disable the broker
   * @public
   * @return {boolean} A boolean true when disabling was successful
   */
  disable() {
    this.enabled = false;
    this.engine.stop();
    return true;
  }

  /**
   * A function to enable the broker
   * @public
   * @return {boolean} A boolean true when enabling was successful
   */
  enable() {
    this.enabled = true;
    this._processQueue();
    return true;
  }

  /**
   * Process the broker's queue of orders
   * @private
   * @return {boolean} A boolean to denote the successful dispatch of the queue processor
   */
  _processQueue() {
    this._dispatchFilledOrderHandler();
    const placeOrdersProcess = new Process(this.placeOrders, this, []);
    const cancelOrdersProcess = new Process(this.cancelOrders, this, []);
    const checkHeartbeatProcess = new Process(this.checkHeartbeat, this, []);
    this.engine.start([placeOrdersProcess, cancelOrdersProcess, checkHeartbeatProcess]);
  }

  /**
   * Load a valid order into the broker's order queue
   * @public
   * @param {Order} order - The order to be loaded into the order queue
   * @param {boolean} [silent=false] - A boolean denoting whether to enable the broker defaults
   * @return {Order} Order that was successfully loaded into the order queue 
   */
  queueOrder(order, silent = false) {
    if (order instanceof Order !== true || !order.valid) {
      throw new TypeError('Must pass a valid order instance');
    }
    this.queue.push(order);
    !silent && !this.enabled && this.enable();
    return order;
  }

  /**
   * Check for the filled state of a placed order
   * @private
   * @param {Object} message - The socket feed message containing a filled order
   * @return {string[]} List of order ids that have been filled
   */
  _checkFilled(message) {
    this.queue.forEach(order => {
    let {size, maker_order_id} = message;
    if (maker_order_id === order.id) {
      const remaining = order.remaining - Number(size);
      remaining > 0 && order.setRemaining(remaining) && order.setStatus('partial');
      remaining === 0 && order.setRemaining(remaining) && order.setStatus('filled');
    }
    });
  return true;
  }

  /**
   * Dispatch a filled order feed listener on the 'user' channel of the exchange feeds
   * @private
   * @return {boolean} A boolean denoting the successful dispatch of the listener
   */
  _dispatchFilledOrderHandler() {
  this.exchange.feeds.on('message', (data) => {
    if (data.type === 'match') {
      this._checkFilled(data);
    }
  });
  return true;
  }

  /**
   * Place any created orders in the queue into the market
   * @async
   * @public
   * @return {Promise<Order[]]>} A list of orders that were placed
   * 
   */
  async placeOrders() {
    const placedOrders = [];
    let placedOrder;
    const ordersToPlace = this.queue.filter(order => order.status === 'created' || order.status === 'cancelled')
    for (var order of ordersToPlace) {
      const bestLimit = this._getLimitPrice(order);
      if (bestLimit <= 0) { return []; }
      order.setLimit(bestLimit);
      order.setStatus('placing');
      try {
        order.valid && (placedOrder = await this.exchange.placeOrder(order));
        order.setId(placedOrder.id);
        placedOrders.push(order);
        order.setStatus('placed');
      } catch (e) {
        throw new Error(e);
      }
    };
    return placedOrders;
  }

  /**
   * Cancel placed orders whose limit price differs from the best price on the orderbook for that product
   * @public
   * @async
   * @return {Promise<Order[]]>} A list of orders that were cancelled
   */
  async cancelOrders() {
    const cancelledOrders = [];
    const ordersToCancel = this.queue.filter(order => order.status === 'placed' || order.status === 'partial')
    for (var order of ordersToCancel) {
      if (this._getLimitPrice(order) !== order.limit) {
        order.setStatus('cancelling');
        try {
          await this.exchange.cancelOrder(order);
          cancelledOrders.push(order);
          order.setStatus('cancelled');
        } catch (e) {
          throw new Error(e);
        }
      }
    };
    return cancelledOrders;
  }

  async checkHeartbeat() {
    if (!this.exchange.lastHeartBeat) {
      return null;
    } else {
      const { time } = this.exchange.lastHeartBeat;
      if (moment(time).isBefore(moment().subtract(5, 'seconds'))) {
        // Reload the feeds like this?
        await this.exchange._loadFeeds();
        return moment().format('hh:mm:ss:SS');
      }
      return moment(time).format('hh:mm:ss:SS');
    }
  }
}

module.exports = Broker;
