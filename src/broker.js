const {EventEmitter} = require('events');
const {AuthenticatedClient, WebsocketClient} = require('gdax');
const Order = require('./order');

/**
 * A class representing a broker.  Instance of this class are generated by the exchange
 */
class Broker extends EventEmitter {
  /**
   * A constructor used to create instances of the broker class
   * @param {Exchange} exchange - An instance of the Exchange class containing a websocket feed and an authenticated client for order execution (executor)
   */
  constructor(exchange={}) {
    super(exchange);
    this.exchange = exchange;
    this.enabled = false;
    this.queue = [];
    this.valid = this._testValid();
  }

  /**
   * Test validity of instances of broker class
   * @private
   * @return {boolean} Boolean representing the validity of instances of broker
   */
  _testValid() {
    return Boolean(
      this.exchange &&
      this.exchange.valid &&
      this.exchange.executor instanceof AuthenticatedClient &&
      this.exchange.feeds instanceof WebsocketClient
    );
  }


  /**
   * A function to get the best limit price according to the current state of the
   * exchange orderbooks
   * @private
   * @param {Order} order - The order about which a current limit price will be determined
   * @return {number} The price of the best limit order
   */
  _getLimitPrice(order) {
    const currentOrderBook = this.exchange.orderBooks[order.product].book;
    return currentOrderBook[order.side === 'buy' ? 'bid' : 'ask'];
  }

  /**
   * A function to disable the broker
   * @public
   * @return {boolean} A boolean true when disabling was successful
   */
  disable() {
    this.enabled = false;
    return true;
  }

  /**
   * A function to enable the broker
   * @public
   * @return {boolean} A boolean true when enabling was successful
   */
  enable() {
    this.enabled = true;
    return true;
  }

  /**
   * Load a valid order into the broker's order queue
   * @public
   * @param {Order} order - The order to be loaded into the order queue
   * @return {Order} Order that was successfully loaded into the order queue 
   */
  queueOrder(order) {
    if (order instanceof Order !== true || !order.valid) {
      throw new TypeError('Must pass a valid order instance');
    }
    this.queue.push(order);
    !this.enabled && this.enable();
    return order;
   }

   /**
    * Place any created orders in the queue into the market
    * @async
    * @public
    * @return {Promise<[Order]>} A list of orders that were placed
    * 
    */
  async placeOrders() {
    const placedOrders = [];
    let placedOrder;
    this.queue.filter(order => order.status === 'created' || order.status === 'cancelled').forEach(async (order) => {
      order.setLimit(this._getLimitPrice(order));
      order.valid && (placedOrder = await this.exchange.placeOrder(order));
      order.setId(placedOrder.id);
      order.setStatus('placed');
      placedOrders.push(order);
    });
    return placedOrders;
  }

  /**
   * Cancel placed orders whose limit price differs from the best price on the orderbook for that product
   * @public
   * @async
   * @return {Promise<[Order]>} A list of orders that were cancelled
   */
  async cancelOrders() {
    const cancelledOrders = [];
    this.queue.filter(order => order.status === 'placed').forEach(async (order) => {
      if (this.exchange.orderBooks[order.product].book[order.side === 'buy' ? 'bid' : 'ask'] !== order.limit) {
        await this.exchange.cancelOrder(order);
        order.setStatus('cancelled');
        cancelledOrders.push(order);
      }
    });
    return cancelledOrders;
  }
}

module.exports = Broker;
